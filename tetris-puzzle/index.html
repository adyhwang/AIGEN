<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>俄罗斯方块拼图 | 经典益智游戏</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    
    <!-- Tailwind 配置 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // 方块颜色定义
                        tetris: {
                            l: '#FF9500',    // L形：橙色
                            j: '#0055D1',    // J形：深蓝色
                            s: '#34C759',    // S形：绿色
                            z: '#FF3B30',    // Z形：红色
                            i: '#007AFF',    // I形：蓝色
                            t: '#AF52DE',    // T形：紫色
                            o: '#FFCC00'     // O形：黄色
                        },
                        game: {
                            bg: '#121212',        // 游戏背景：深灰黑色
                            panel: '#1E1E1E',     // 面板背景：深灰色
                            grid: '#2D2D2D',      // 网格线：中灰色
                            target: '#3A3A3A',    // 目标图形：浅灰色
                            text: '#FFFFFF',      // 文字：白色
                            accent: '#BB86FC',    // 强调色：亮紫色
                            hint: '#00FFFF'       // 提示色：青色
                        }
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif']
                    },
                    boxShadow: {
                        'tetris': '0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2)',
                        'tetris-hover': '0 10px 15px -3px rgba(0, 0, 0, 0.4), 0 4px 6px -2px rgba(0, 0, 0, 0.2)',
                        'highlight': '0 0 15px rgba(255, 255, 255, 0.5), 0 0 5px rgba(255, 255, 255, 0.8)',
                        'pulse': '0 0 10px rgba(187, 134, 252, 0.7), 0 0 20px rgba(187, 134, 252, 0.5)',
                        'hint': '0 0 15px rgba(255, 255, 255, 0.8), 0 0 5px rgba(255, 255, 255, 0.8)',
                        'target-hint': '0 0 8px rgba(255, 255, 255, 0.8)'
                    }
                }
            }
        }
    </script>
    
    <!-- 自定义工具类 -->
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .grid-cell {
                @apply border border-game-grid/30;
            }
            .tetris-piece {
                @apply transition-all duration-150 cursor-move select-none;
                touch-action: none; /* 禁用触摸动作的默认行为 */
            }
            .tetris-block {
                @apply shadow-md transition-all duration-150;
            }
            .btn-game {
                @apply bg-game-panel hover:bg-game-panel/80 text-game-text py-2 px-4 rounded-lg transition-all duration-200 transform hover:scale-105 active:scale-95 shadow-md flex items-center gap-2;
            }
            .grid-container {
                @apply bg-game-panel rounded-xl shadow-lg overflow-hidden relative;
            }
            .piece-container {
                @apply relative overflow-hidden;
            }
            .pulse-animation {
                animation: pulse 1.2s infinite;
            }
            @keyframes pulse {
                0%, 100% { 
                    opacity: 1;
                    transform: scale(1);
                    box-shadow: 0 0 10px rgba(187, 134, 252, 0.5);
                }
                50% { 
                    opacity: 0.8;
                    transform: scale(1.05);
                    box-shadow: 0 0 20px rgba(187, 134, 252, 0.8);
                }
            }
            .hint-pulse {
                animation: hintPulse 1.2s infinite;
            }
            @keyframes hintPulse {
                0%, 100% { 
                    opacity: 0.7;
                    box-shadow: 0 0 10px rgba(255, 255, 255, 0.6);
                }
                50% { 
                    opacity: 1;
                    box-shadow: 0 0 20px rgba(255, 255, 255, 0.9);
                }
            }
            .target-hint-pulse {
                animation: targetHintPulse 1.2s infinite;
            }
            @keyframes targetHintPulse {
                0%, 100% { 
                    opacity: 0.8;
                    box-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
                }
                50% { 
                    opacity: 1;
                    box-shadow: 0 0 15px rgba(255, 255, 255, 0.9);
                }
            }
            .success-animation {
                animation: success 0.5s ease-in-out;
            }
            @keyframes success {
                0% { transform: scale(1); }
                50% { transform: scale(1.1); }
                100% { transform: scale(1); }
            }
            /* 自定义下拉框样式 */
            .custom-select {
                background-color: #1E1E1E;
                color: #FFFFFF;
                border: 1px solid rgba(187, 134, 252, 0.5);
                border-radius: 4px;
            }
            .custom-select option {
                background-color: #1E1E1E;
                color: #FFFFFF;
            }
            .custom-select:focus {
                outline: none;
                border-color: #BB86FC;
                box-shadow: 0 0 0 2px rgba(187, 134, 252, 0.2);
            }
        }
    </style>
    
    <style>
        /* 基础样式设置，移除滚动条 */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        
        /* 游戏容器自适应缩放 */
        .game-wrapper {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        /* 确保游戏区域始终保持左中右结构 */
        .game-main-area {
            display: flex;
            width: 100%;
            flex: 1;
            gap: 2vw;
            min-height: 0;
            justify-content: center;
            align-items: center;
        }
        
        /* 确保所有容器使用相同的盒模型 */
        .side-container, .center-container, 
        #left-grid, #right-grid, #target-grid,
        .grid-container {
            box-sizing: border-box;
        }
        
        /* 左侧和右侧容器宽度固定比例 */
        .side-container {
            width: 20vw;
            min-width: 0;
        }
        
        /* 中间目标容器宽度固定比例 */
        .center-container {
            width: 40vw;
            min-width: 0;
        }
        
        /* 防止双击缩放 */
        * {
            touch-action: manipulation;
        }
        
        /* 确保内容不会溢出容器 */
        .grid-container {
            max-width: 100%;
            max-height: 100%;
        }
        
        /* 提示方块样式 - 确保与目标方块使用相同的盒模型 */
        .hint-block {
            position: absolute;
            z-index: 10;
            border: 2px solid white;
            box-sizing: border-box; /* 关键：确保边框包含在尺寸内 */
        }

        /* 全屏模式下的样式调整 */
        .fullscreen-active {
            background-color: #000;
        }
        
        .fullscreen-active .game-wrapper {
            padding: 0;
        }
        
        /* 全屏按钮样式 */
        .fullscreen-btn {
            @apply bg-game-accent/30 hover:bg-game-accent/50;
        }
        
        /* 目标形状提示样式 */
        .target-block.hint {
            opacity: 0.9; /* 提高提示时目标形状的不透明度，确保覆盖方块 */
            border: 2px solid rgba(255, 255, 255, 0.7);
        }
        
        /* 明确设置z-index层级关系 */
        #target-grid {
            z-index: 1;
        }
        
        .target-block {
            z-index: 2; /* 目标形状基础层级（在方块之下） */
        }
        
        .target-block.hint-active {
            z-index: 40; /* 提示时目标形状层级（在所有方块之上） */
        }
        
        .tetris-piece {
            z-index: 10; /* 方块始终在目标形状之上（非提示状态） */
        }
        
        .tetris-piece.z-20 {
            z-index: 20; /* 拖拽时层级更高 */
        }
        
        .tetris-piece.z-30 {
            z-index: 30; /* 提示时方块层级（仍在提示目标形状之下） */
        }
        
        /* 过关通知设置最高层级 */
        #success-message {
            z-index: 100;
        }
    </style>
    
    <!-- 引入字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>

<body class="bg-game-bg text-game-text font-sans">
    <div class="game-wrapper">
        <!-- 游戏容器 -->
        <div class="w-full max-w-7xl mx-auto flex flex-col items-center h-full">
            <!-- 顶部区域：标题和关卡信息 -->
            <header class="w-full mb-3 flex flex-col md:flex-row justify-between items-center gap-2">
                <div class="flex items-center gap-2">
                    <div class="tetris-block bg-tetris-l"></div>
                    <div class="tetris-block bg-tetris-j"></div>
                    <div class="tetris-block bg-tetris-s"></div>
                    <h1 class="text-[clamp(1rem,5vw,1.8rem)] font-bold tracking-tight">俄罗斯方块拼图</h1>
                </div>
                
                <div class="bg-game-panel px-3 py-1.5 rounded-lg shadow-md flex items-center gap-4">
                    <div class="flex items-center gap-1.5">
                        <i class="fa fa-signal text-game-accent text-sm"></i>
                        <select id="difficulty" class="custom-select px-2 py-1 text-sm bg-game-panel text-game-text">
                            <option value="easy">简单</option>
                            <option value="medium">一般</option>
                            <option value="hard">困难</option>
                        </select>
                    </div>
                    <div class="flex items-center gap-1.5">
                        <i class="fa fa-map-signs text-game-accent text-sm"></i>
                        <span class="text-sm">关卡: <span id="level-display" class="font-bold">1</span>/<span id="total-levels" class="font-medium">60</span></span>
                    </div>
                    <div class="flex items-center gap-1.5">
                        <i class="fa fa-cubes text-game-accent text-sm"></i>
                        <span class="text-sm">方块: <span id="pieces-count" class="font-bold">2</span>个</span>
                    </div>
                </div>
            </header>
            
            <!-- 中间游戏区域 - 强制保持左中右结构 -->
            <main class="game-main-area mb-3 flex-1">
                <!-- 左侧方块区 - 固定比例宽度 -->
                <div class="side-container grid-container" id="left-container">
                    <div class="p-1.5 bg-game-panel/80 text-center text-xs md:text-sm font-medium border-b border-game-grid">左侧方块</div>
                    <div id="left-grid" class="p-0 grid grid-cols-9 gap-0 piece-container"></div>
                </div>
                
                <!-- 中间目标图形区 - 固定比例宽度，高度减少2行 -->
                <div class="center-container grid-container relative" id="target-container">
                    <div class="p-1.5 bg-game-panel/80 text-center text-xs md:text-sm font-medium border-b border-game-grid">目标图形</div>
                    <div id="target-grid" class="p-0 grid grid-cols-16 gap-0 relative piece-container"></div>
                    <!-- 通关提示覆盖层 - 确保最高层级 -->
                    <div id="success-message" class="absolute inset-0 bg-game-bg/80 flex flex-col items-center justify-center gap-4 rounded-xl opacity-0 pointer-events-none transition-opacity duration-500 z-100">
                        <div class="text-4xl font-bold text-game-accent success-animation">通关!</div>
                        <p class="text-lg">太棒了，准备好挑战下一关了吗？</p>
                    </div>
                </div>
                
                <!-- 右侧方块区 - 固定比例宽度 -->
                <div class="side-container grid-container" id="right-container">
                    <div class="p-1.5 bg-game-panel/80 text-center text-xs md:text-sm font-medium border-b border-game-grid">右侧方块</div>
                    <div id="right-grid" class="p-0 grid grid-cols-8 gap-0 piece-container"></div>
                </div>
            </main>
            
            <!-- 底部控制按钮区 - 响应式大小 -->
            <footer class="w-full flex flex-wrap justify-center gap-2 mb-1">
                <button id="reset-btn" class="btn-game text-sm md:text-base">
                    <i class="fa fa-refresh"></i>
                    <span>重置</span>
                </button>
                <button id="hint-btn" class="btn-game bg-game-accent/20 hover:bg-game-accent/30 text-sm md:text-base">
                    <i class="fa fa-lightbulb-o"></i>
                    <span>提示</span>
                </button>
                <button id="fullscreen-btn" class="btn-game fullscreen-btn text-sm md:text-base">
                    <i class="fa fa-expand"></i>
                    <span>全屏</span>
                </button>
                <button id="next-btn" class="btn-game bg-game-accent hover:bg-game-accent/80 text-sm md:text-base">
                    <i class="fa fa-arrow-right"></i>
                    <span>下一关</span>
                </button>
            </footer>
        </div>
    </div>

    <script>
        // 计算网格大小，确保在不同屏幕上都能完整显示且保持左中右结构
        function calculateGridSize() {
            // 获取实际容器元素及其尺寸
            const leftContainer = document.getElementById('left-container');
            const rightContainer = document.getElementById('right-container');
            const targetContainer = document.getElementById('target-container');
            
            // 确保容器已渲染
            if (!leftContainer || !rightContainer || !targetContainer) {
                return 10; // 默认大小
            }
            
            // 获取容器的实际可用空间（减去标题栏）
            const getAvailableSpace = (container) => {
                const style = window.getComputedStyle(container);
                const paddingTop = parseFloat(style.paddingTop);
                const paddingBottom = parseFloat(style.paddingBottom);
                const titleHeight = container.querySelector('div:first-child').offsetHeight;
                const totalVerticalPadding = paddingTop + paddingBottom + titleHeight;
                
                return {
                    width: container.offsetWidth,
                    height: container.offsetHeight - totalVerticalPadding
                };
            };
            
            const leftSpace = getAvailableSpace(leftContainer);
            const rightSpace = getAvailableSpace(rightContainer);
            const targetSpace = getAvailableSpace(targetContainer);
            
            // 计算基于各容器宽度的最大可能网格大小
            const leftBasedSize = leftSpace.width / 9;  // 左侧9列
            const rightBasedSize = rightSpace.width / 8; // 右侧8列
            const centerBasedSize = targetSpace.width / 16;  // 中间16列
            
            // 计算基于各容器高度的最大可能网格大小
            // 中间目标区域高度减少2行，从16行变为14行
            const leftHeightBased = leftSpace.height / 10;  // 左侧10行
            const rightHeightBased = rightSpace.height / 10; // 右侧10行
            const centerHeightBased = targetSpace.height / 14;  // 中间14行（减少了2行）
            
            // 取所有可能值中的最小值作为基础网格大小
            const baseSize = Math.min(
                leftBasedSize, rightBasedSize, centerBasedSize,
                leftHeightBased, rightHeightBased, centerHeightBased
            );
            
            // 确保网格大小是整数，避免小数像素导致的错位
            let gridSize = Math.floor(baseSize);
            
            // 微调网格大小，确保能完全填充容器宽度
            const adjustForPerfectFit = (containerWidth, cols, currentSize) => {
                // 计算理想大小使容器能被列数整除
                const idealSize = containerWidth / cols;
                // 尝试向上或向下取整，找到最接近理想大小的整数
                const roundedUp = Math.ceil(idealSize);
                const roundedDown = Math.floor(idealSize);
                
                // 选择更接近理想大小的值
                return Math.abs(roundedUp - idealSize) < Math.abs(roundedDown - idealSize) 
                    ? roundedUp 
                    : roundedDown;
            };
            
            // 为每个容器调整网格大小，确保完美匹配
            const leftAdjusted = adjustForPerfectFit(leftSpace.width, 9, gridSize);
            const rightAdjusted = adjustForPerfectFit(rightSpace.width, 8, gridSize);
            const centerAdjusted = adjustForPerfectFit(targetSpace.width, 16, gridSize);
            
            // 取调整后的最小值，确保所有容器都能适应
            gridSize = Math.min(leftAdjusted, rightAdjusted, centerAdjusted);
            
            // 确保网格大小至少为10px，防止过小
            return Math.max(gridSize, 10);
        }

        // 游戏状态
        const gameState = {
            difficulty: 'easy',
            level: 1,
            totalLevels: 60, // 默认简单难度总关卡数
            pieces: [], // 所有方块
            usedPieceIds: [], // 当前关卡使用的方块ID
            pieceCount: 2, // 当前关卡需要的方块数量
            targetShape: [], // 目标形状
            targetShapeColors: new Map(), // 目标形状每个位置的颜色
            isDragging: false,
            draggedPiece: null,
            dragOffset: { x: 0, y: 0 },
            gridSize: calculateGridSize(), // 动态计算每个网格的像素大小
            hintActive: false, // 提示是否激活
            hintTimer: null, // 提示计时器
            hintedPieces: [], // 当前提示的所有方块
            lastTouchTime: 0, // 用于检测双击的时间戳
            touchCount: 0, // 触摸计数
            touchTimeout: null, // 触摸超时计时器
            isFullscreen: false // 全屏状态
        };

        // 方块定义：形状、颜色和初始位置
        const pieceDefinitions = {
            // 左侧方块 (id 1-7)
            1: { type: 'l', color: 'tetris-l', rotation: 0, container: 'left' },
            2: { type: 'j', color: 'tetris-j', rotation: 0, container: 'left' },
            3: { type: 'z', color: 'tetris-z', rotation: 0, container: 'left' },
            4: { type: 's', color: 'tetris-s', rotation: 0, container: 'left' },
            5: { type: 'o', color: 'tetris-o', rotation: 0, container: 'left' },
            6: { type: 't', color: 'tetris-t', rotation: 0, container: 'left' },
            7: { type: 'i', color: 'tetris-i', rotation: 0, container: 'left' },
            
            // 右侧方块 (id 8-14)
            8: { type: 'l', color: 'tetris-l', rotation: 0, container: 'right' },
            9: { type: 'j', color: 'tetris-j', rotation: 0, container: 'right' },
            10: { type: 'z', color: 'tetris-z', rotation: 0, container: 'right' },
            11: { type: 's', color: 'tetris-s', rotation: 0, container: 'right' },
            12: { type: 'o', color: 'tetris-o', rotation: 0, container: 'right' },
            13: { type: 't', color: 'tetris-t', rotation: 0, container: 'right' },
            14: { type: 'i', color: 'tetris-i', rotation: 0, container: 'right' }
        };

        // 方块形状定义 (每个方向的形状) - 全部以左上角为原点，确保一致性
        const shapes = {
            // L形旋转定义 - 已标准化
            l: [
                [[0, 0], [1, 0], [2, 0], [2, 1]], // 0度
                [[1, 0], [1, 1], [1, 2], [0, 2]], // 90度
                [[0, 0], [0, 1], [1, 1], [2, 1]], // 180度
                [[1, 0], [0, 0], [0, 1], [0, 2]]  // 270度
            ],
            // J形旋转定义 - 已标准化
            j: [
                [[0, 1], [1, 1], [2, 1], [2, 0]], // 0度
                [[0, 0], [1, 0], [1, 1], [1, 2]], // 90度
                [[0, 0], [0, 1], [1, 0], [2, 0]], // 180度
                [[1, 0], [1, 1], [1, 2], [2, 2]]  // 270度
            ],
            s: [
                [[0, 1], [0, 2], [1, 0], [1, 1]], // 0度 (横向)
                [[0, 0], [1, 0], [1, 1], [2, 1]], // 90度
                [[0, 1], [0, 2], [1, 0], [1, 1]], // 180度
                [[0, 0], [1, 0], [1, 1], [2, 1]]  // 270度
            ],
            z: [
                [[0, 0], [0, 1], [1, 1], [1, 2]], // 0度 (横向)
                [[1, 0], [2, 0], [0, 1], [1, 1]], // 90度
                [[0, 0], [0, 1], [1, 1], [1, 2]], // 180度
                [[1, 0], [2, 0], [0, 1], [1, 1]]  // 270度
            ],
            i: [
                [[0, 0], [0, 1], [0, 2], [0, 3]], // 0度 (横向)
                [[0, 0], [1, 0], [2, 0], [3, 0]], // 90度
                [[0, 0], [0, 1], [0, 2], [0, 3]], // 180度
                [[0, 0], [1, 0], [2, 0], [3, 0]]  // 270度
            ],
            t: [
                [[0, 1], [1, 0], [1, 1], [1, 2]], // 0度 (横向)
                [[0, 1], [1, 1], [1, 2], [2, 1]], // 90度
                [[1, 0], [1, 1], [1, 2], [2, 1]], // 180度
                [[0, 1], [1, 0], [1, 1], [2, 1]]  // 270度
            ],
            o: [
                [[0, 0], [0, 1], [1, 0], [1, 1]], // 0度 (横向)
                [[0, 0], [0, 1], [1, 0], [1, 1]], // 90度
                [[0, 0], [0, 1], [1, 0], [1, 1]], // 180度
                [[0, 0], [0, 1], [1, 0], [1, 1]]  // 270度
            ]
        };

        // 初始位置定义
        const initialPositions = {
            // 左侧方块位置 (9x10网格)
            1: { row: 0, col: 0 },    // L形 - 第1行左边
            2: { row: 0, col: 5 },    // J形 - 第1行右边
            3: { row: 3, col: 0 },    // Z形 - 第4行左边
            4: { row: 3, col: 5 },    // S形 - 第4行右边
            5: { row: 5, col: 0 },    // O形 - 第6行左边
            6: { row: 5, col: 5 },    // T形 - 第6行右边
            7: { row: 8, col: 2 },    // I形 - 第9行中间
            
            // 右侧方块位置 (8x10网格)
            8: { row: 0, col: 0 },    // L形 - 第1行
            9: { row: 0, col: 4 },    // J形 - 第1行
            10: { row: 3, col: 0 },   // Z形 - 第4行
            11: { row: 3, col: 4 },   // S形 - 第4行
            12: { row: 5, col: 0 },   // O形 - 第6行
            13: { row: 5, col: 4 },   // T形 - 第6行
            14: { row: 8, col: 1 }    // I形 - 第9行
        };

        // DOM 元素
        const leftGrid = document.getElementById('left-grid');
        const rightGrid = document.getElementById('right-grid');
        const targetGrid = document.getElementById('target-grid');
        const difficultySelect = document.getElementById('difficulty');
        const levelDisplay = document.getElementById('level-display');
        const totalLevelsDisplay = document.getElementById('total-levels');
        const piecesCountDisplay = document.getElementById('pieces-count');
        const resetBtn = document.getElementById('reset-btn');
        const hintBtn = document.getElementById('hint-btn');
        const nextBtn = document.getElementById('next-btn');
        const successMessage = document.getElementById('success-message');
        const targetContainer = document.getElementById('target-container');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const fullscreenIcon = fullscreenBtn.querySelector('i');
        const fullscreenText = fullscreenBtn.querySelector('span');

        // 初始化游戏
        function initGame() {
            // 创建网格背景
            createGridBackground(leftGrid, 9, 10);
            createGridBackground(rightGrid, 8, 10);
            createGridBackground(targetGrid, 16, 14); // 中间目标区域高度减少2行，从16行变为14行
            
            // 加载保存的进度
            loadGameProgress();
            
            // 创建所有方块
            createAllPieces();
            
            // 生成当前关卡
            generateLevel();
            
            // 添加事件监听器
            addEventListeners();
            
            // 窗口大小变化时重新计算网格大小
            window.addEventListener('resize', handleResize);
            
            // 监听全屏状态变化
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('msfullscreenchange', handleFullscreenChange);
            
            // 初始布局后再调整一次大小，确保精确匹配
            setTimeout(handleResize, 100);
        }

        // 处理全屏状态变化
        function handleFullscreenChange() {
            // 检查当前是否处于全屏状态
            gameState.isFullscreen = !!document.fullscreenElement ||
                                    !!document.webkitFullscreenElement ||
                                    !!document.mozFullScreenElement ||
                                    !!document.msFullscreenElement;
            
            // 更新按钮状态
            if (gameState.isFullscreen) {
                fullscreenIcon.className = 'fa fa-compress';
                fullscreenText.textContent = '退出全屏';
                document.body.classList.add('fullscreen-active');
            } else {
                fullscreenIcon.className = 'fa fa-expand';
                fullscreenText.textContent = '全屏';
                document.body.classList.remove('fullscreen-active');
            }
            
            // 调整网格大小以适应新的屏幕尺寸
            handleResize();
        }

        // 切换全屏模式
        function toggleFullscreen() {
            // 检查是否已经处于全屏状态
            if (!gameState.isFullscreen) {
                // 尝试进入全屏
                const docEl = document.documentElement;
                
                if (docEl.requestFullscreen) {
                    docEl.requestFullscreen().catch(err => {
                        console.error(`进入全屏模式失败: ${err.message}`);
                    });
                } else if (docEl.webkitRequestFullscreen) { // Safari
                    docEl.webkitRequestFullscreen().catch(err => {
                        console.error(`进入全屏模式失败: ${err.message}`);
                    });
                } else if (docEl.msRequestFullscreen) { // IE/Edge
                    docEl.msRequestFullscreen().catch(err => {
                        console.error(`进入全屏模式失败: ${err.message}`);
                    });
                }
            } else {
                // 退出全屏
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { // Safari
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { // IE/Edge
                    document.msExitFullscreen();
                }
            }
        }

        // 处理窗口大小变化
        function handleResize() {
            // 保存当前网格大小用于计算偏移
            const oldSize = gameState.gridSize;
            
            // 重新计算网格大小
            gameState.gridSize = calculateGridSize();
            
            // 计算缩放比例，用于调整方块位置
            const scaleRatio = gameState.gridSize / oldSize;
            
            // 重新创建网格背景
            clearGrid(leftGrid);
            clearGrid(rightGrid);
            clearGrid(targetGrid);
            
            createGridBackground(leftGrid, 9, 10);
            createGridBackground(rightGrid, 8, 10);
            createGridBackground(targetGrid, 16, 14); // 中间目标区域高度减少2行
            
            // 重新渲染所有方块，并根据新的网格大小调整位置
            gameState.pieces.forEach(piece => {
                // 根据缩放比例调整位置，保持相对位置不变
                piece.col = Math.round(piece.col * scaleRatio);
                piece.row = Math.round(piece.row * scaleRatio);
                renderPiece(piece);
            });
            
            // 重新渲染目标形状
            renderTargetShape();
        }

        // 清空网格
        function clearGrid(grid) {
            while (grid.firstChild) {
                grid.removeChild(grid.firstChild);
            }
        }

        // 创建网格背景 - 确保网格大小精确匹配
        function createGridBackground(container, cols, rows) {
            // 设置网格容器的精确尺寸
            const gridSize = gameState.gridSize;
            const containerWidth = cols * gridSize;
            const containerHeight = rows * gridSize;
            
            container.style.gridTemplateColumns = `repeat(${cols}, ${gridSize}px)`;
            container.style.width = `${containerWidth}px`;
            container.style.height = `${containerHeight}px`;
            container.style.position = 'relative';
            
            // 设置网格单元格大小
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.style.width = `${gridSize}px`;
                    cell.style.height = `${gridSize}px`;
                    cell.style.boxSizing = 'border-box'; // 确保边框包含在尺寸内
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    container.appendChild(cell);
                }
            }
        }

        // 创建所有方块
        function createAllPieces() {
            gameState.pieces = [];
            
            // 创建左侧和右侧的方块
            for (let id = 1; id <= 14; id++) {
                const piece = createPiece(id);
                gameState.pieces.push(piece);
                renderPiece(piece);
            }
        }

        // 创建单个方块
        function createPiece(id) {
            const def = pieceDefinitions[id];
            const pos = initialPositions[id];
            
            return {
                id,
                type: def.type,
                color: def.color,
                rotation: def.rotation,
                container: def.container,
                row: pos.row,
                col: pos.col,
                originalRow: pos.row,
                originalCol: pos.col,
                originalContainer: def.container,
                element: null
            };
        }

        // 渲染方块 - 确保与网格大小精确匹配
        function renderPiece(piece) {
            // 如果方块元素已存在，先移除
            if (piece.element) {
                piece.element.remove();
            }
            
            const gridSize = gameState.gridSize;
            
            // 创建方块容器
            const pieceEl = document.createElement('div');
            pieceEl.className = 'tetris-piece absolute';
            pieceEl.dataset.id = piece.id;
            pieceEl.dataset.type = piece.type;
            
            // 如果提示激活，设置方块层级为30（在提示目标形状之下）
            if (gameState.hintActive) {
                pieceEl.classList.add('z-30');
            }
            
            // 获取当前旋转状态的形状
            const shape = shapes[piece.type][piece.rotation];
            
            // 设置方块位置 - 使用精确的网格计算
            pieceEl.style.left = `${piece.col * gridSize}px`;
            pieceEl.style.top = `${piece.row * gridSize}px`;
            
            // 创建方块的每个部分 - 确保大小与网格匹配
            shape.forEach(([dr, dc]) => {
                const block = document.createElement('div');
                block.className = `tetris-block bg-${piece.color} absolute`;
                block.style.width = `${gridSize}px`;
                block.style.height = `${gridSize}px`;
                block.style.left = `${dc * gridSize}px`;
                block.style.top = `${dr * gridSize}px`;
                block.style.boxSizing = 'border-box'; // 确保边框包含在尺寸内
                pieceEl.appendChild(block);
            });
            
            // 添加到容器
            const container = piece.container === 'left' ? leftGrid : 
                             piece.container === 'right' ? rightGrid : targetGrid;
            container.appendChild(pieceEl);
            piece.element = pieceEl;
            
            // 添加拖拽和旋转事件
            addPieceEvents(piece);
            
            // 确保方块在容器内
            constrainPieceToContainer(piece);
        }

        // 确保方块保持在容器内
        function constrainPieceToContainer(piece) {
            if (!piece.element) return;
            
            const container = piece.container === 'left' ? leftGrid : 
                             piece.container === 'right' ? rightGrid : targetGrid;
            
            // 获取容器尺寸（列数和行数）
            const cols = piece.container === 'left' ? 9 : 
                        piece.container === 'right' ? 8 : 16;
            const rows = piece.container === 'left' || piece.container === 'right' ? 10 : 14; // 中间目标区域14行
            
            // 获取方块形状和尺寸
            const shape = shapes[piece.type][piece.rotation];
            const maxDr = Math.max(...shape.map(([dr, _]) => dr));
            const maxDc = Math.max(...shape.map(([_, dc]) => dc));
            
            // 计算最大允许位置
            const maxCol = cols - maxDc - 1;
            const maxRow = rows - maxDr - 1;
            
            // 约束位置在有效范围内
            piece.col = Math.max(0, Math.min(piece.col, maxCol));
            piece.row = Math.max(0, Math.min(piece.row, maxRow));
            
            // 更新位置
            piece.element.style.left = `${piece.col * gameState.gridSize}px`;
            piece.element.style.top = `${piece.row * gameState.gridSize}px`;
        }

        // 为方块添加事件 - 增强移动端支持
        function addPieceEvents(piece) {
            const el = piece.element;
            
            // 鼠标双击旋转
            el.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                rotatePiece(piece);
            });
            
            // 触摸事件 - 移动端支持，增强双击检测
            el.addEventListener('touchstart', (e) => {
                e.preventDefault(); // 防止默认行为
                
                const now = Date.now();
                const timeSinceLastTouch = now - gameState.lastTouchTime;
                
                // 检测双击（300ms内的两次触摸）
                if (timeSinceLastTouch < 300 && timeSinceLastTouch > 0) {
                    // 这是双击，旋转方块
                    rotatePiece(piece);
                    
                    // 重置触摸计数和计时器
                    gameState.touchCount = 0;
                    if (gameState.touchTimeout) {
                        clearTimeout(gameState.touchTimeout);
                        gameState.touchTimeout = null;
                    }
                } else {
                    // 第一次触摸，启动拖拽
                    const touch = e.touches[0];
                    startDrag(piece, touch);
                    
                    // 增加触摸计数
                    gameState.touchCount++;
                    
                    // 设置超时，300ms内没有第二次触摸则重置计数
                    if (gameState.touchTimeout) {
                        clearTimeout(gameState.touchTimeout);
                    }
                    
                    gameState.touchTimeout = setTimeout(() => {
                        gameState.touchCount = 0;
                    }, 300);
                }
                
                // 更新最后触摸时间
                gameState.lastTouchTime = now;
            }, { passive: false });
            
            // 鼠标开始拖拽事件
            el.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                startDrag(piece, e);
            });
        }

        // 旋转方块
        function rotatePiece(piece) {
            // 保存当前位置
            const oldRow = piece.row;
            const oldCol = piece.col;
            
            // 更新旋转状态 (0 -> 1 -> 2 -> 3 -> 0)
            piece.rotation = (piece.rotation + 1) % 4;
            
            // 重新渲染
            renderPiece(piece);
            
            // 检查旋转后是否超出容器，如果是则调整位置
            constrainPieceToContainer(piece);
        }

        // 开始拖拽 - 同时支持鼠标和触摸事件
        function startDrag(piece, e) {
            gameState.isDragging = true;
            gameState.draggedPiece = piece;
            
            // 计算鼠标/触摸在方块内的偏移
            const rect = piece.element.getBoundingClientRect();
            gameState.dragOffset.x = e.clientX - rect.left;
            gameState.dragOffset.y = e.clientY - rect.top;
            
            // 提升拖拽元素层级，但仍低于提示目标形状
            piece.element.classList.add('z-20', 'scale-110', 'shadow-tetris-hover');
            
            // 添加移动和结束事件监听
            document.addEventListener('mousemove', dragMove);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('mouseleave', stopDrag);
            
            // 触摸事件 - 移动端支持
            document.addEventListener('touchmove', touchDragMove, { passive: false });
            document.addEventListener('touchend', touchStopDrag);
            document.addEventListener('touchcancel', touchStopDrag);
        }

        // 触摸移动事件处理
        function touchDragMove(e) {
            e.preventDefault(); // 防止页面滚动
            if (e.touches && e.touches.length > 0) {
                dragMove(e.touches[0]);
            }
        }

        // 触摸结束事件处理
        function touchStopDrag() {
            stopDrag();
            // 移除触摸事件监听
            document.removeEventListener('touchmove', touchDragMove);
            document.removeEventListener('touchend', touchStopDrag);
            document.removeEventListener('touchcancel', touchStopDrag);
        }

        // 拖拽移动 - 优化跟手效果并确保与网格对齐
        function dragMove(e) {
            if (!gameState.isDragging || !gameState.draggedPiece) return;
            
            const piece = gameState.draggedPiece;
            const gridSize = gameState.gridSize;
            
            // 获取当前容器和其位置信息
            const currentContainer = piece.container === 'left' ? leftGrid : 
                                    piece.container === 'right' ? rightGrid : targetGrid;
            const currentContainerRect = currentContainer.getBoundingClientRect();
            
            // 计算相对于当前容器的位置（以网格为单位）
            let x = e.clientX - currentContainerRect.left - gameState.dragOffset.x;
            let y = e.clientY - currentContainerRect.top - gameState.dragOffset.y;
            
            // 转换为网格坐标
            let col = Math.round(x / gridSize);
            let row = Math.round(y / gridSize);
            
            // 检查是否需要切换到目标容器
            const targetRect = targetGrid.getBoundingClientRect();
            const isOverTarget = e.clientX >= targetRect.left && 
                                e.clientX <= targetRect.right && 
                                e.clientY >= targetRect.top && 
                                e.clientY <= targetRect.bottom;
            
            // 如果是从左右容器拖到目标容器
            if (isOverTarget && piece.container !== 'target') {
                // 移除旧容器中的元素
                piece.element.remove();
                
                // 更新容器
                piece.container = 'target';
                
                // 添加到目标容器
                targetGrid.appendChild(piece.element);
                
                // 重新计算位置（以网格为单位）
                x = e.clientX - targetRect.left - gameState.dragOffset.x;
                y = e.clientY - targetRect.top - gameState.dragOffset.y;
                col = Math.round(x / gridSize);
                row = Math.round(y / gridSize);
            } 
            // 如果是从目标容器拖回左右容器
            else if (!isOverTarget && piece.container === 'target') {
                // 判断是更靠近左侧还是右侧容器
                const leftRect = leftGrid.getBoundingClientRect();
                const rightRect = rightGrid.getBoundingClientRect();
                
                const distToLeft = Math.hypot(e.clientX - leftRect.left, e.clientY - leftRect.top);
                const distToRight = Math.hypot(e.clientX - rightRect.left, e.clientY - rightRect.top);
                
                const newContainer = distToLeft < distToRight ? 'left' : 'right';
                
                // 移除旧容器中的元素
                piece.element.remove();
                
                // 更新容器
                piece.container = newContainer;
                
                // 添加到新容器
                (newContainer === 'left' ? leftGrid : rightGrid).appendChild(piece.element);
                
                // 重新计算位置（以网格为单位）
                const newContainerRect = newContainer === 'left' ? leftRect : rightRect;
                x = e.clientX - newContainerRect.left - gameState.dragOffset.x;
                y = e.clientY - newContainerRect.top - gameState.dragOffset.y;
                col = Math.round(x / gridSize);
                row = Math.round(y / gridSize);
            }
            
            // 获取形状信息
            const shape = shapes[piece.type][piece.rotation];
            const maxDc = Math.max(...shape.map(([_, dc]) => dc));
            const maxDr = Math.max(...shape.map(([dr, _]) => dr));
            
            // 获取容器尺寸（列数和行数）
            const cols = piece.container === 'left' ? 9 : 
                        piece.container === 'right' ? 8 : 16;
            const rows = piece.container === 'left' || piece.container === 'right' ? 10 : 14; // 中间目标区域14行
            
            // 计算最大允许位置
            const maxCol = cols - maxDc - 1;
            const maxRow = rows - maxDr - 1;
            
            // 约束位置在有效范围内
            piece.col = Math.max(0, Math.min(col, maxCol));
            piece.row = Math.max(0, Math.min(row, maxRow));
            
            // 直接设置位置，确保与网格对齐
            piece.element.style.left = `${piece.col * gridSize}px`;
            piece.element.style.top = `${piece.row * gridSize}px`;
        }

        // 停止拖拽
        function stopDrag() {
            if (!gameState.isDragging || !gameState.draggedPiece) return;
            
            const piece = gameState.draggedPiece;
            const gridSize = gameState.gridSize;
            
            // 恢复样式，但保持z-index高于目标形状（非提示状态）
            piece.element.classList.remove('z-20', 'scale-110', 'shadow-tetris-hover');
            
            // 如果提示激活，确保方块保持在z-30层级
            if (gameState.hintActive) {
                piece.element.classList.add('z-30');
            }
            
            // 确保最终位置精确对齐网格
            piece.element.style.left = `${piece.col * gridSize}px`;
            piece.element.style.top = `${piece.row * gridSize}px`;
            
            // 检查是否完成关卡
            checkLevelCompletion();
            
            // 如果放置了提示的方块，清除提示
            if (gameState.hintActive && gameState.hintedPieces.some(hp => hp.id === piece.id)) {
                // 检查是否所有提示方块都已放置
                const remainingHints = gameState.hintedPieces.filter(hp => 
                    !gameState.pieces.some(p => p.id === hp.id && p.container === 'target')
                );
                
                if (remainingHints.length === 0) {
                    clearHint();
                } else {
                    // 更新提示，只显示剩余未放置的方块
                    updateHintForRemainingPieces(remainingHints);
                }
            }
            
            // 重置拖拽状态
            gameState.isDragging = false;
            gameState.draggedPiece = null;
            
            // 移除鼠标事件监听
            document.removeEventListener('mousemove', dragMove);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('mouseleave', stopDrag);
        }

        // 根据难度和当前关卡计算所需方块数量
        function calculatePieceCount() {
            let minPieces, maxPieces, totalLevels;
            
            // 根据难度设置参数
            switch(gameState.difficulty) {
                case 'easy':
                    minPieces = 2;
                    maxPieces = 4;
                    totalLevels = 60;
                    break;
                case 'medium':
                    minPieces = 5;
                    maxPieces = 8;
                    totalLevels = 80;
                    break;
                case 'hard':
                    minPieces = 9;
                    maxPieces = 14;
                    totalLevels = 100;
                    break;
            }
            
            // 更新总关卡数
            gameState.totalLevels = totalLevels;
            totalLevelsDisplay.textContent = totalLevels;
            
            // 计算关卡进度比例 (0-1)
            const progress = (gameState.level - 1) / (totalLevels - 1);
            
            // 计算基于进度的方块数量（渐进式增加）
            const pieceCount = Math.round(minPieces + progress * (maxPieces - minPieces));
            
            // 确保不超出范围
            return Math.max(minPieces, Math.min(pieceCount, maxPieces));
        }

        // 生成关卡
        function generateLevel() {
            // 清空目标区域
            clearTargetArea();
            
            // 根据难度和当前关卡计算方块数量
            gameState.pieceCount = calculatePieceCount();
            piecesCountDisplay.textContent = gameState.pieceCount;
            
            // 随机选择方块
            const allPieceIds = Array.from({length: 14}, (_, i) => i + 1);
            gameState.usedPieceIds = [];
            
            while (gameState.usedPieceIds.length < gameState.pieceCount) {
                const randomId = allPieceIds[Math.floor(Math.random() * allPieceIds.length)];
                if (!gameState.usedPieceIds.includes(randomId)) {
                    gameState.usedPieceIds.push(randomId);
                }
            }
            
            // 生成目标形状
            generateTargetShape();
        }

        // 清空目标区域
        function clearTargetArea() {
            // 重置所有方块到初始位置
            gameState.pieces.forEach(piece => {
                piece.row = piece.originalRow;
                piece.col = piece.originalCol;
                piece.container = piece.originalContainer;
                piece.rotation = 0;
                renderPiece(piece);
            });
            
            // 清空目标形状
            gameState.targetShape = [];
            gameState.targetShapeColors.clear();
            document.querySelectorAll('#target-grid .target-block').forEach(block => {
                block.remove();
            });
            
            // 隐藏成功消息
            successMessage.classList.add('opacity-0', 'pointer-events-none');
            
            // 清除提示
            clearHint();
        }

        // 生成目标形状 - 从第二行和第二列开始生成
        function generateTargetShape() {
            // 基于选中的方块生成一个相连的形状
            const targetBlocks = new Set();
            const usedPieces = gameState.pieces.filter(p => gameState.usedPieceIds.includes(p.id));
            gameState.targetShapeColors.clear();
            
            // 随机放置每个方块，确保相连
            let placed = false;
            let attempts = 0;
            
            // 中间目标区域现在是16列x14行
            const targetCols = 16;
            const targetRows = 14;
            
            // 目标形状的边界限制：
            // 1. 从第二行（索引1）和第二列（索引1）开始生成
            // 2. 不要出现在最左列（0）和最右列（15）
            // 3. 不要出现在最上行（0）和最下行（13）
            const minCol = 1;       // 从第二列开始（索引1）
            const maxCol = targetCols - 2;  // 避开最右列
            const minRow = 1;       // 从第二行开始（索引1）
            const maxRow = targetRows - 2;  // 避开最下行
            
            while (!placed && attempts < 100) {
                attempts++;
                targetBlocks.clear();
                gameState.targetShapeColors.clear();
                
                // 第一个方块从第二行和第二列开始放置
                const firstPiece = usedPieces[0];
                const firstRotation = Math.floor(Math.random() * 4);
                const startRow = Math.floor(Math.random() * (maxRow - minRow + 1)) + minRow; // 随机行，但在允许范围内
                const startCol = Math.floor(Math.random() * (maxCol - minCol + 1)) + minCol; // 随机列，但在允许范围内
                
                // 获取第一个方块的形状
                const shape = shapes[firstPiece.type][firstRotation];
                let firstPieceValid = true;
                
                shape.forEach(([dr, dc]) => {
                    const r = startRow + dr;
                    const c = startCol + dc;
                    
                    // 检查是否超出边界限制
                    if (r < minRow || r > maxRow || c < minCol || c > maxCol) {
                        firstPieceValid = false;
                    }
                    
                    targetBlocks.add(`${r},${c}`);
                    gameState.targetShapeColors.set(`${r},${c}`, firstPiece.color);
                });
                
                if (!firstPieceValid) continue;
                
                // 放置剩余方块
                let allPlaced = true;
                for (let i = 1; i < usedPieces.length; i++) {
                    const piece = usedPieces[i];
                    const rotation = Math.floor(Math.random() * 4);
                    const shape = shapes[piece.type][rotation];
                    let placedPiece = false;
                    
                    // 尝试在已放置的方块附近放置新方块
                    for (let attempt = 0; attempt < 50; attempt++) {
                        // 随机选择一个已放置的方块作为参考点
                        const existingBlocks = Array.from(targetBlocks);
                        const [refRow, refCol] = existingBlocks[Math.floor(Math.random() * existingBlocks.length)].split(',').map(Number);
                        
                        // 随机方向和距离
                        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                        const [dr, dc] = directions[Math.floor(Math.random() * directions.length)];
                        
                        // 计算放置位置
                        const baseRow = refRow + dr;
                        const baseCol = refCol + dc;
                        
                        // 检查是否可以放置
                        let canPlace = true;
                        const newBlocks = [];
                        
                        shape.forEach(([sr, sc]) => {
                            const r = baseRow + sr;
                            const c = baseCol + sc;
                            
                            // 检查是否超出边界限制
                            if (r < minRow || r > maxRow || c < minCol || c > maxCol) {
                                canPlace = false;
                            }
                            
                            // 检查是否与已有方块重叠
                            if (targetBlocks.has(`${r},${c}`)) {
                                canPlace = false;
                            }
                            
                            newBlocks.push(`${r},${c}`);
                        });
                        
                        // 如果可以放置，添加到目标形状
                        if (canPlace) {
                            newBlocks.forEach(block => {
                                targetBlocks.add(block);
                                gameState.targetShapeColors.set(block, piece.color);
                            });
                            placedPiece = true;
                            break;
                        }
                    }
                    
                    if (!placedPiece) {
                        allPlaced = false;
                        break;
                    }
                }
                
                if (allPlaced) {
                    placed = true;
                }
            }
            
            // 保存目标形状并渲染
            gameState.targetShape = Array.from(targetBlocks).map(block => {
                const [r, c] = block.split(',').map(Number);
                return { row: r, col: c };
            });
            
            renderTargetShape();
        }

        // 渲染目标形状 - 确保与网格匹配
        function renderTargetShape() {
            // 清除现有目标块
            document.querySelectorAll('#target-grid .target-block').forEach(block => {
                block.remove();
            });
            
            const gridSize = gameState.gridSize;
            
            // 获取目标网格容器的样式，特别是内边距
            const targetGridStyle = window.getComputedStyle(targetGrid);
            const targetPaddingTop = parseFloat(targetGridStyle.paddingTop);
            const targetPaddingLeft = parseFloat(targetGridStyle.paddingLeft);
            
            // 创建新的目标块
            gameState.targetShape.forEach(({ row, col }) => {
                const blockId = `${row},${col}`;
                const block = document.createElement('div');
                
                // 基础样式
                let classes = 'tetris-block absolute target-block';
                
                // 根据是否提示状态设置不同的样式
                if (gameState.hintActive) {
                    // 提示状态：使用实际颜色，提高不透明度，添加高亮效果和置顶层级
                    const color = gameState.targetShapeColors.get(blockId);
                    classes += ` bg-${color} opacity-95 hint target-hint-pulse hint-active`;
                } else {
                    // 非提示状态：使用目标颜色，降低不透明度，层级在方块之下
                    classes += ' bg-game-target opacity-70';
                }
                
                block.className = classes;
                block.style.width = `${gridSize}px`;
                block.style.height = `${gridSize}px`;
                block.style.left = `${col * gridSize + targetPaddingLeft}px`;
                block.style.top = `${row * gridSize + targetPaddingTop}px`;
                block.style.boxSizing = 'border-box'; // 确保边框包含在尺寸内
                targetGrid.appendChild(block);
            });
        }

        // 检查关卡完成情况
        function checkLevelCompletion() {
            // 收集所有放置在目标区域的方块的所有块
            const placedBlocks = new Set();
            
            gameState.pieces.forEach(piece => {
                if (piece.container === 'target') {
                    const shape = shapes[piece.type][piece.rotation];
                    shape.forEach(([dr, dc]) => {
                        const r = piece.row + dr;
                        const c = piece.col + dc;
                        placedBlocks.add(`${r},${c}`);
                    });
                }
            });
            
            // 收集目标形状的所有块
            const targetBlocks = new Set(gameState.targetShape.map(({ row, col }) => `${row},${col}`));
            
            // 检查是否完全匹配
            if (placedBlocks.size === targetBlocks.size) {
                let isComplete = true;
                
                placedBlocks.forEach(block => {
                    if (!targetBlocks.has(block)) {
                        isComplete = false;
                    }
                });
                
                if (isComplete) {
                    completeLevel();
                }
            }
        }

        // 完成关卡
        function completeLevel() {
            // 显示成功消息（已设置最高z-index）
            successMessage.classList.remove('opacity-0', 'pointer-events-none');
            
            // 更新关卡，不超过当前难度的最大关卡数
            if (gameState.level < gameState.totalLevels) {
                gameState.level++;
            } else {
                // 如果达到当前难度的最大关卡数，循环回到第一关
                gameState.level = 1;
            }
            
            // 更新显示
            levelDisplay.textContent = gameState.level;
            
            // 保存进度
            saveGameProgress();
        }

        // 重置方块
        function resetPieces() {
            gameState.pieces.forEach(piece => {
                piece.row = piece.originalRow;
                piece.col = piece.originalCol;
                piece.container = piece.originalContainer;
                // 保持旋转状态不变
                renderPiece(piece);
            });
            
            // 清除提示
            clearHint();
        }

        // 清除提示
        function clearHint() {
            if (gameState.hintActive) {
                // 重置提示状态
                gameState.hintActive = false;
                gameState.hintedPieces = [];
                
                // 重置方块样式和层级
                document.querySelectorAll('.tetris-piece').forEach(el => {
                    el.classList.remove('shadow-hint', 'pulse-animation', 'scale-110', 'z-30', 'opacity-70');
                    
                    // 恢复方块原始不透明度
                    el.querySelectorAll('.tetris-block').forEach(block => {
                        block.style.opacity = '1';
                    });
                });
                
                // 重新渲染目标形状以恢复原始样式和层级
                renderTargetShape();
                
                // 清除计时器
                if (gameState.hintTimer) {
                    clearTimeout(gameState.hintTimer);
                    gameState.hintTimer = null;
                }
            }
        }

        // 更新剩余提示方块
        function updateHintForRemainingPieces(remainingPieces) {
            // 重置所有方块样式
            document.querySelectorAll('.tetris-piece').forEach(el => {
                el.classList.remove('shadow-hint', 'pulse-animation', 'scale-110');
            });
            
            // 更新提示的方块列表
            gameState.hintedPieces = remainingPieces;
            
            // 为剩余方块添加提示样式
            remainingPieces.forEach(piece => {
                const pieceEl = document.querySelector(`.tetris-piece[data-id="${piece.id}"]`);
                if (pieceEl) {
                    pieceEl.classList.add('shadow-hint', 'pulse-animation', 'scale-110');
                }
            });
        }

        // 显示提示 - 目标形状置顶并覆盖方块颜色
        function showHint() {
            // 如果已有提示，先清除
            clearHint();
            
            gameState.hintActive = true;
            gameState.hintedPieces = [];
            
            // 获取已放置在目标区域的方块
            const placedPieces = gameState.pieces.filter(p => p.container === 'target');
            
            // 获取已放置的所有块
            const placedBlocks = new Set();
            placedPieces.forEach(piece => {
                const shape = shapes[piece.type][piece.rotation];
                shape.forEach(([dr, dc]) => {
                    const r = piece.row + dr;
                    const c = piece.col + dc;
                    placedBlocks.add(`${r},${c}`);
                });
            });
            
            // 获取尚未使用的方块
            const unusedPieces = gameState.pieces.filter(p => 
                gameState.usedPieceIds.includes(p.id) && p.container !== 'target'
            );
            
            if (unusedPieces.length === 0) {
                return; // 没有可用方块，不显示提示
            }
            
            // 更新提示的方块列表
            gameState.hintedPieces = unusedPieces;
            
            // 为提示方块添加样式
            unusedPieces.forEach(piece => {
                const pieceEl = document.querySelector(`.tetris-piece[data-id="${piece.id}"]`);
                if (pieceEl) {
                    pieceEl.classList.add('shadow-hint', 'pulse-animation', 'scale-110');
                }
            });
            
            // 重新渲染所有方块，确保它们在提示目标形状之下
            gameState.pieces.forEach(piece => {
                renderPiece(piece);
            });
            
            // 重新渲染目标形状，使其置顶并显示真实颜色
            renderTargetShape();
            
            // 2.5秒后移除提示
            gameState.hintTimer = setTimeout(() => {
                clearHint();
            }, 2500);
        }

        // 下一关
        function nextLevel() {
            if (gameState.level < gameState.totalLevels) {
                gameState.level++;
            } else {
                gameState.level = 1;
            }
            
            levelDisplay.textContent = gameState.level;
            generateLevel();
            saveGameProgress();
        }

        // 保存游戏进度
        function saveGameProgress() {
            const progress = {
                difficulty: gameState.difficulty,
                level: gameState.level
            };
            
            localStorage.setItem('tetrisPuzzleProgress', JSON.stringify(progress));
        }

        // 加载游戏进度
        function loadGameProgress() {
            const savedProgress = localStorage.getItem('tetrisPuzzleProgress');
            
            if (savedProgress) {
                const progress = JSON.parse(savedProgress);
                gameState.difficulty = progress.difficulty || 'easy';
                gameState.level = progress.level || 1;
                
                // 更新UI
                difficultySelect.value = gameState.difficulty;
                levelDisplay.textContent = gameState.level;
            }
            
            // 根据难度设置总关卡数
            switch(gameState.difficulty) {
                case 'easy':
                    gameState.totalLevels = 60;
                    break;
                case 'medium':
                    gameState.totalLevels = 80;
                    break;
                case 'hard':
                    gameState.totalLevels = 100;
                    break;
            }
            
            totalLevelsDisplay.textContent = gameState.totalLevels;
        }

        // 添加事件监听器
        function addEventListeners() {
            // 难度选择变化
            difficultySelect.addEventListener('change', () => {
                gameState.difficulty = difficultySelect.value;
                
                // 根据新难度设置总关卡数和重置当前关卡
                switch(gameState.difficulty) {
                    case 'easy':
                        gameState.totalLevels = 60;
                        break;
                    case 'medium':
                        gameState.totalLevels = 80;
                        break;
                    case 'hard':
                        gameState.totalLevels = 100;
                        break;
                }
                
                totalLevelsDisplay.textContent = gameState.totalLevels;
                gameState.level = 1;
                levelDisplay.textContent = gameState.level;
                generateLevel();
                saveGameProgress();
            });
            
            // 重置按钮
            resetBtn.addEventListener('click', resetPieces);
            
            // 提示按钮
            hintBtn.addEventListener('click', showHint);
            
            // 全屏按钮
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            
            // 下一关按钮
            nextBtn.addEventListener('click', nextLevel);
            
            // 点击目标区域空白处取消选择
            targetGrid.addEventListener('click', () => {
                if (gameState.isDragging) {
                    stopDrag();
                }
            });
            
            // 防止拖动时选择文本
            document.addEventListener('dragstart', (e) => e.preventDefault());
            
            // 防止触摸时页面缩放或滚动
            document.addEventListener('touchmove', (e) => {
                if (gameState.isDragging) {
                    e.preventDefault();
                }
            }, { passive: false });
        }

        // 初始化游戏
        window.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
    
